\section{Introduction}
The role of JavaScript dramatically changed over the last years. From an unpopular language used to add dynamic effects to webpages to a widely used language with a strong and growing community. It emerged from a browser only language to a general programing language used to write web-,  desktop- and mobile- applications but also server components. This shift is reflected in an increasing complexity and number of JavaScript projects. To tackle the higher complexity, a better tooling support is needed for effective development and refactoring.  

JavaScript does not provide any static analysis for proving the soundness of a program. Type and nullability checking is performed at runtime. Performing refactorings or adding new functionality is therefore a risky task, as the programer has a very limited tooling for testing if changes have been applied correctly. By applying the type checking statically instead of at runtime, common errors like accessing not declared variables, missing arguments, arguments in incorrect order or invoking a non function type can be detected and reported to the developer, without the need to execute the program. 

JavaScript is an implicitly typed language and therefore requires type inference for type checking. Type inference for JavaScript is a non trivial task because of the very dynamic nature of JavaScript~\cite{JensenMollerThiemann2009}. An explanation of the most important aspects follows.

\begin{description}
	\item[Dynamic Objects] A JavaScript object is a mapping from a string key to a value. Adding new properties or removing existing once can be performed dynamically. The names of properties can be computed values. Such operations often require reflection in statically typed languages.

	\item[Side effects] JavaScript has support for higher order functions, functions accepting other functions as parameter. In comparison to functional languages, functions do not need to be pure and therefore can have side effects to their declaration scope or passed parameters. 
	
	\item[Closure] Functions have access to variables from their enclosing scope. Invoking a function requires that the function is evaluated in its declaration scope. 
	
	\item[This binding] The object referenced by \javascriptinline/this/ depends on the kind of function and its usage. Arrow functions capture the \javascriptinline/this/ of the enclosing context. The \javascriptinline/this/ of function declarations or expressions depends on the usage. The \javascriptinline/this/ can explicitly be specified if the function is invoked using \javascriptinline/call/ or \javascriptinline/apply/. Otherwise the binding of \javascriptinline/this/ is implicitly defined. If the function is called as a method of an object, then \javascriptinline/this/ is equal to the object, to which the method belongs. If the function is not a member of an object, then \javascriptinline/this/ is \javascriptinline/undefined/. 

	\item[Environment] The preliminary target of JavaScript applications is still the Browser. But it can also be executed standalone using NodeJS, Rhino or another JavaScript engine. These engines expose different native objects and methods at runtime, e.g. the browser exposes the DOM-Model. The type checker needs to model these object and methods specially as their JavaScript-Code is not existent.

\end{description}

An alternative and quite popular approach for type checking programs executing in a JavaScript environment is by transpiling a source language into JavaScript. The source language either allows type inference or contains type annotations that make type checking possible. Well known examples are TypeScript~\cite{Microsoft2012} and Flow~\cite{Facebook2014}. The downside of a transpiled language is an additional required build step that slows down the development cycle and is a potential source for additional errors. A developer using a transpiled language needs to have a good understanding of the source language and JavaScript. This limits the number of potential recruiting candidates or requires additional training.

Its assumed that most of the code rarely uses reflection like code and therefore precise type inference is possible. Reflective code is most commonly used in libraries or frameworks. Type inference for frameworks and libraries can be substituted by using external declaration files to make type checking possible. The goal of this project thesis is to show a type inference and type checking algorithm for JavaScript that is precise and sound for the most common JavaScript code, but might be unsound or imprecise for non trivial code segments. The analysis is optimized for ECMAScript 6 code written in strict mode. Features prohibited in strict mode are not supported by the analysis.

