\section{Evaluation}
As part of this work, the tool ESChecker has been implemented. It applies the described algorithm. The set of implemented JavaScript features is not sufficient to perform an evaluation using real live projects. Instead, sample listenings are used to compare the implementation with Flow, TAJS and infernu. Infernu and TAJS do not support ES5 and therefore ES5 equivalents of the listings are used.

\subsection{Variable redefinement}
In JavaScript, values of different types can be assigned to the same variable. Therefore the same variable can have different types at different positions in the program. The following listing defers the initialization of the variable.

\javascriptfile{./evaluation/redefined-variable.js}

Infernu is the only tool that rejects the program. Infernu defines a strict type system that does not allow assignments to variables with incompatible types. In this example, an object value is assigned to a variable of type \javascriptinline{undefined}. 

\subsection{Closures}
JavaScript supports closures, allowing functions to read and modify variables from the outer scope. The analysis needs to be context sensitive to support closures. 

\javascriptfile{./evaluation/closure.js}

Closures are supported by all evaluated tools.

\subsection{Side effects}
Functions can have side effects to the enclosing scope or parameters. In the following example, a new property is assigned to the passed in object. These side effects needs to be reflected in the callers context.

\javascriptfile{./evaluation/effects.js}

Infernu rejects the program as types are sealed after first passing them as argument to a function. Flow rejects the program with for the same reason. The intention of flow is to detect spelling errors and therefore only allows access to already defined properties. 

The program is accepted by TAJS and ESChecker.


\subsection{Function overloading}
JavaScript does not provide built in support for function overloading. A function can only have one definition. But the number of arguments passed for a function call do not need to exactly match the number of parameters in the function declaration. This allows optional arguments. The following example provides a \javascriptinline{range} function that can be called with one or up to three arguments\footnote{The implementation cannot use the default parameters of ES6 as the semantic of the passed arguments depends on the number of arguments. If the function is called with a single argument, then the \javascriptinline{start} and \javascriptinline{end} value need to be switched.}. 

\javascriptfile{./evaluation/function-overloading.js}

Infernu rejects the program, as it cannot handle optional arguments. A function needs always to be invoked with exactly the same number of arguments as parameters defined in the function declaration. The other tools type check the program correctly.

\subsection{Callbacks}
Callbacks are commonly used in JavaScript for asynchronous and functional programing. Functions can be passed like values in function calls. This requires tracking of the passed function and evaluation with the passed arguments when its called. The following example implements the map function and applies it to a number array to double its values. The map function calls a callback for each array element and puts the result in the resulting array. The example also contains a second application of the map function with a string array to test if rank-1 polymorphism is supported. % TODO CITE

\javascriptfile{./evaluation/callbacks.js}

This example is supported by all tools except Flow. Flow seems not to support type inference for rank-1 polymorph functions. The example type checks if either type annotations are added to the map function or if \javascriptinline{map} is only applied once or with arrays of equal types. 

\subsection{Built in types}
ECMAScript defines built in objects and functions. These functions are natively implemented and not available as JavaScript source code, hence the source code cannot be analyzed by the type checker or type inference algorithm. This requires that native object and functions are defined in the type checker or that it provides an external declaration of these. The following example uses the native \javascriptinline{map} and \javascriptinline{reduce} function. The arguments passed to \javascriptinline{reduce} are intentionally in the wrong order to test if the type checker validates callbacks passed to built in functions. The first argument of \javascriptinline{reduce} is the callback, the second the accumulator initialization value\footnote{As infernu does not support optional arguments, all callback arguments have been added to the callbacks of map and reduce before analyzing the example with infernu.}. 

\javascriptfile{./evaluation/built-ins.js}

Infernu rejects the example as it does not support the built in \javascriptinline{reduce} method. TAJS rejects the example as it does not support the built in \javascriptinline{map} method. Flow and ESChecker correctly type the application of the \javascriptinline{map} function and reject the application of the \javascriptinline{reduce} function.

\subsection{DOM Events}
JavaScript is often used in the browser to add dynamics to a web page. This requires interaction with the DOM. A type checker needs to model the DOM and its type, as needed for other built in types like arrays. Modeling the DOM requires to define the built in types and methods, but also to model the browser events~\cite{JensenMadsenMoller2011}. Reacting to user input is done by registering a listener for a particular event on a specific DOM-Element, like an input field. The api for registering listeners is generic, but the event passed to the listeners depends on the event type. A \texttt{keydown} event passes a \javascriptinline{KeyboardEvent} object to the listener. The \javascriptinline{KeyboardEvent} has additional properties allowing the identification of the pressed key. The type of the event is defined by the name of the event passed in by the listener registration as shown in the following example.

\javascriptfile{./evaluation/event-handlers.js}

The given example is correct for the keydown event, as the \javascriptinline{KeyboardEvent} defines a method \javascriptinline{getModifierState}. The second registration should fail, as the click event defines no method \javascriptinline{getModifierState}. 

None of the inspected tools correctly identifies this error. Infernu has no support for the DOM at all and therefore rejects the program because \javascriptinline{document} is undefined. ESChecker reports an error and TAJS a warning that the variable \javascriptinline{search} potentially can be \javascriptinline{null} and therefore the event handler cannot be registered on line 10. ESChecker is neither path sensitive nor does it evaluate the tests in if expressions. Therefore it assumes that \javascriptinline{search} might be \javascriptinline{null}. The same seems to be true for TAJS, but its unknown if it does not evaluate the if condition or lacks path sensitivity. 

Flow is the only tool that does not reject the given example. The external definition of the DOM api implies that flow has a special overload for keyboard and non keyboard events and therefore should be capable to correctly type the given example\footnote{Flow supports external definition files only containing declarations. One of this declaration files describes the DOM \url{https://github.com/facebook/flow/blob/master/lib/dom.js\#L99}}. But flow does not reject the second registration, even if the event misses the \javascriptinline{getModifierState} method. Its currently unknown why the example is not rejected. Flow achieves the overloading by defining an enum with the keyboard event names. 

A special handling for DOM events is beneficial, as it adds additional type safety. But events are not only used when interacting with the DOM, but also if frameworks are being used. E.g. Backbone makes strong use of events, for the internal implementation but also in its api. Frameworks like Angular are completely abstracting DOM events and binds the event handlers dynamically. The binding of the callback methods on the controller are defined in the HTML view belonging to this controller. This case is very hard to handle... TODO redefine paragraph. 

\subsection{Summarized}
