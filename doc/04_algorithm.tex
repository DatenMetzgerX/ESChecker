\section{Algorithm}
The classical approach for type inference is the Hindley Milner algorithm~\cite{Milner1978}. This work combines the Hindley Milner algorithm W with abstract interpretation. This allows inferring the most specific type for every variable at every position in the program. The classical Hindley Milner algorithm identifies the principal type for every variable in the whole program. The principal type is not sufficient for JavaScript. Compared to ML-Like languages, the type of a variable can change in Javascript. Either the variable is initialized after its declaration or a value with a different type is assigned to a variable. Hence, every position in the program requires its own type environment. This is achieved by using a data flow based analysis. 

The control graph used for the data flow analysis is statement based. For each statement in the program one control flow graph node is created. Each edge represents a potential control flow between two statements. The control flow graph is not created on expression level to reduce the number of nodes and therefore the number of states required during the data flow analysis.  

The analysis uses the work list~\cite{NielsonNielsonHankin1999} algorithm to traverse the control flow nodes in forward order. The analysis is not path sensitive. The order of the nodes is the same as the order of the statements in the program. The transfer function infers the type for the statement using the Hindley Milner algorithm W. Therefore all types for the statement and its expressions are inferred. The output of the transfer function is the modified type environment that contains the types for the inferred variables. Two branches are joined by merging the type environments. The merged type environment is an union of the both type environments. Conflicting mappings are merged by using the unification function of the Hindley Milner algorithm that returns the most general type.

A function declared in JavaScript has access to its declaration context. These functions are also known as closures. Therefore the data flow analysis needs to be context sensitive. Context sensitivity is achieved by inlining the invoked function. Calling a function requires that the type environment of the caller is merged with the type environment from the callee declaration. The merged type environment contains the mappings from both type environments. The type of the callers context overrides the mapping of the declaration type environment for conflicting mappings. 