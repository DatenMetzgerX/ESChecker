\section{Related Work}
The work relates with linters, transpiled languages and other projects with the goal for a type checker for JavaScript. 

Linters like ESLint~\cite{jQuery2016} are used to enforce a specific coding style across a project or to find errors using common bug patterns. Linters use only trivial analysis to find bugs, mostly scoped to a single function. This work focuses on errors deducible by type checking, based on a sophisticated inter procedural analysis. 


This work relates to transpiled languages that support type checking. The source language is either a language with complete type inference\cite{Ekblad2012, McKenna} or requires type annotations. Flow~\cite{Facebook2014} and TypeScript~\cite{Microsoft2012} are an example where a superset of JavaScript with support for type annotations is used as source language.  This work differs from transpilers as the focus is on type checking JavaScript and not a super set.

TAJS~\cite{JensenMollerThiemann2009} is a sound type analyzer and type checker for JavaScript. TAJS uses, context and path sensitive, abstract interpretation to infer the types for every term. The goal of TAJS is a precise and sound type checker that supports the full ECMAScript language. Compared to TAJS, this works is focused only on JavaScript programs using strict mode. Additionally the analysis does not need to be sound. 

Infernu~\cite{Lewis} implements type inference and type checking. Infernu defines a strict type system that only allows a subset of JavaScript. It uses the Damas-Hindley-Milner Algorithm for type inference and type checking. This works differs from infernu as its not limited to a strict subset of JavaScript.

Tern~\cite{Haverbeke} is an editor independent JavaScript analyzer with type inference. Editors can use the Tern api to query type information, provide auto completion and jump to definition functionality. Tern uses abstract values and abstract interpretation for type inference. Tern can only infer types for functions with an invocation. Not invoked functions are not analyzed. The work differs from Tern as the project focuses on type checking and not on providing an api for editors. 

%By contrast to the related work, the work described in this paper implements a type inference and type checking for ECMAScript. The focus lies on code written using ECMAScript 6 for different execution environments like NodeJS or browsers. The main goal is not to achieve a high precision for all JavaScript constructs, instead a compromise between a fast and precise algorithm has been chosen. The in precision and required computation time of the inference algorithm can be improved by adding type annotations by JSDoc or external typescript definition files. Its expected that type annotations are preliminary needed for libraries and seldom for user defined code. Further only code according to strict mode is supported. Strict mode does not support the usage of deprecated features from earlier ECMAScript versions. Strict mode is enforced for all code using ECMASCript 6 modules and therefore can be expected to be the default for new code~\cite[10.2.1]{Ecma2015}. 
%
%The available tools as today are linters and transpilers. Linters focus on enforcing a code style and finding simple, intra procedural errors. 
%
% ESLint~\cite{jQuery2016} perform type checking that check the code for mostly code style and inter procedural errors or transpilers~\cite{Lewis, Haverbeke, McKenna, Ekblad2012} that translate a code base from one language into JavaScript. In general, transpilers provide static analysis like type checking, that supports programing in larger teams and to perform static refactorings. The best known to JavaScript transpiled languages are TypeScript from Microsoft~\cite{Microsoft2012} and Flow from Facebook\cite{Facebook2014}. 
%
%
%Using transpiled languages increases the complexity of the built step. The source code base needs to be transpiled into JavaScript before it's execution. To be able to correlate errors with the location in the source language, source maps need to be used. It also requires that a developer has a good understanding of the source language and JavaScript. Therefor it would be beneficial if static analysis tools like type checking can be provided for JavaScript. 
%
%Adding type inference and type checking to JavaScript is non trivial because of its vary dynamic nature~\cite{JensenMollerThiemann2009}. Reflection like mechanisms like dynamic object creation or modification is widely used in many famous libraries like jQuery, Angular or Lodash. A lot of work has been investigated in implementing a decidable and precise type checker for the complete set of JavaScript in the browser environment~\cite{JensenMadsenMoller2011, JensenMollerThiemann2009}. 

