\section{Related Work}
The work can be related with linters like ESLint~\cite{jQuery2016}. Linters enforce a coding style and analyze the program for errors by using common bug patterns. The bug patterns are mostly limited to intra procedural errors. In comparison to linters, this work focuses on inter procedural errors, more specific, errors deducible by type checking. 

This work relates to transpiled languages that support type checking. These languages are either a superset of JavaScript~\cite{Microsoft2012, Facebook2014} and use type annotations to solve the type inference problem or are based on a source language that supports type checking\cite{Ekblad2012, McKenna}. In comparison to transpiled languages, the work focuses on type checking for JavaScript. 

Tern~\cite{Haverbeke} is an editor independent JavaScript analyzer. It performs type inference. An Editors can use the tern api to query type information, provide auto completion and jump to definition functionality. Tern uses abstract values and abstract interpretation for type inference. Tern can only infer types for functions with an invocation. Not invoked functions are not analyzed. The work differs from Tern as the project focuses on type checking and not on providing an api for editors. 

TAJS~\cite{JensenMollerThiemann2009} is a type analyzer for JavaScript. It uses a context and path sensitive algorithm that is based on abstract interpretation. TAJS infers the types for every term and type checks the program. The goal of TAJS is a precise type analyzer that supports the full ECMASCript language. The work differs from TAJS that the focus is limited to JavaScript programs using strict mode and supports ES6.

Infernu~\cite{Lewis} implements type inference and type checking. Infernu defines a strict type system that only allows a subset of JavaScript. It uses the Damas-Hindley-Milner Algorithm for type inference and type checking. The work differs from Infernu as Infernu infers the principal type for a term. This work describes an algorithm that infers the most specific type for every position in the program. 

%By contrast to the related work, the work described in this paper implements a type inference and type checking for ECMAScript. The focus lies on code written using ECMAScript 6 for different execution environments like NodeJS or browsers. The main goal is not to achieve a high precision for all JavaScript constructs, instead a compromise between a fast and precise algorithm has been chosen. The in precision and required computation time of the inference algorithm can be improved by adding type annotations by JSDoc or external typescript definition files. Its expected that type annotations are preliminary needed for libraries and seldom for user defined code. Further only code according to strict mode is supported. Strict mode does not support the usage of deprecated features from earlier ECMAScript versions. Strict mode is enforced for all code using ECMASCript 6 modules and therefore can be expected to be the default for new code~\cite[10.2.1]{Ecma2015}. 
%
%The available tools as today are linters and transpilers. Linters focus on enforcing a code style and finding simple, intra procedural errors. 
%
% ESLint~\cite{jQuery2016} perform type checking that check the code for mostly code style and inter procedural errors or transpilers~\cite{Lewis, Haverbeke, McKenna, Ekblad2012} that translate a code base from one language into JavaScript. In general, transpilers provide static analysis like type checking, that supports programing in larger teams and to perform static refactorings. The best known to JavaScript transpiled languages are TypeScript from Microsoft~\cite{Microsoft2012} and Flow from Facebook\cite{Facebook2014}. 
%
%
%Using transpiled languages increases the complexity of the built step. The source code base needs to be transpiled into JavaScript before it's execution. To be able to correlate errors with the location in the source language, source maps need to be used. It also requires that a developer has a good understanding of the source language and JavaScript. Therefor it would be beneficial if static analysis tools like type checking can be provided for JavaScript. 
%
%Adding type inference and type checking to JavaScript is non trivial because of its vary dynamic nature~\cite{JensenMollerThiemann2009}. Reflection like mechanisms like dynamic object creation or modification is widely used in many famous libraries like jQuery, Angular or Lodash. A lot of work has been investigated in implementing a decidable and precise type checker for the complete set of JavaScript in the browser environment~\cite{JensenMadsenMoller2011, JensenMollerThiemann2009}. 

